%{
	#include <iostream>
	#include <string>
	#include <list>
	#include <cassert>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"
	#include "Exceptions.h"
    #include "source.h"
    #include "bp.hpp"

    #define YYSTYPE NonTerminal
    extern list<string> varsListToTypesList(const list<Variable>& varList);

    extern int yylineno;
    int yylex();
    void yyerror(const char*);
    bool isInWhile = false;

    CodeBuffer& codeManager = CodeBuffer::instance();

    void myExit(){
         Framework::getInstance().exitOnError = true;
         exit(0);
    }

    bool isByteSize(string& val){
        int dec_val = std::stoi(val);
        if (dec_val <=255 && dec_val >= 0){
            return true;
        }
        return false;
    }

    void isSetSize(const string& first_num_string, const string& second_num_string){
        int first_num = std::stoi(first_num_string);
        int second_num = std::stoi(second_num_string);
        if (second_num - first_num > 256 || second_num - first_num <= 0){
            output::errorSetTooLarge(yylineno, first_num_string, second_num_string);
            myExit();
        }
    }

    void insertBoolIntoRegister(NonTerminal& boolExp){
        // generate IfTrue, IfFalse labels
        string IFTRUE_label = Framework::getInstance().freshLabel("IfTrue");
        string IFFALSE_label = Framework::getInstance().freshLabel("IfFalse");

        // backpatch IfTrue, IfFalse labels into boolExp
        codeManager.bpatch(boolExp.falseList, IFFALSE_label);
        codeManager.bpatch(boolExp.trueList, IFTRUE_label);

        // generate jump code from IfTrue, IfFalse labels to a third label AssignLabel
        string assign_label = Framework::getInstance().freshLabel("assignBool");
        codeManager.emitLabel(IFTRUE_label);
        codeManager.emitJmp(assign_label);
        codeManager.emitLabel(IFFALSE_label);
        codeManager.emitJmp(assign_label);
        codeManager.emitLabel(assign_label);

        // generate freshTemp, assign to it with phi based on which label it returned from (IfTrue/IfFalse)
        string boolResult = Framework::getInstance().freshTemp();
        codeManager.emitPhi(IFTRUE_label, "1", IFFALSE_label, "0", boolResult);

        // update boolExp.place to contain newly generated register
        boolExp.place = boolResult;
    }

    pair<bpatch_address, bpatch_address> compare(const string& operand1, const string& operand2, const string& operation){
        //test for relation
        string boolRelation = Framework::getInstance().freshTemp();
        codeManager.emitCond(operation, operand1, operand2, boolRelation);

        //jump accordingly
        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitBpatchIf(boolRelation);
        return bpatchRequests;
    }

    void checkInRange(const string& operandSet, const string& operandNum, const string& currentRelop){
        //  prepare labels
        string outOfRangeLabel = Framework::getInstance().freshLabel("outOfRangeError");
        string maybeInRangeLabel = Framework::getInstance().freshLabel("maybeInRange");
        string inRangeLabel = Framework::getInstance().freshLabel("inRange");

        //  get set range
        string setBegin = Framework::getInstance().freshTemp();
        codeManager.emitSetExtractBegin(operandSet, setBegin);
        string setEnd = Framework::getInstance().freshTemp();
        codeManager.emitSetExtractEnd(operandSet, setEnd);

        //  check lower bound
        pair<bpatch_address, bpatch_address> bpatchRequests1 = compare(setBegin, operandNum, "sgt");
        codeManager.bpatch(codeManager.makelist(bpatchRequests1.first), outOfRangeLabel);
        codeManager.bpatch(codeManager.makelist(bpatchRequests1.second), maybeInRangeLabel);

        //  check upper bound
        codeManager.emitLabel(maybeInRangeLabel);
        pair<bpatch_address, bpatch_address> bpatchRequests2 = compare(setEnd, operandNum, "slt");
        codeManager.bpatch(codeManager.makelist(bpatchRequests2.first), outOfRangeLabel);
        codeManager.bpatch(codeManager.makelist(bpatchRequests2.second), inRangeLabel);

        //  throw out of range error
        codeManager.emitLabel(outOfRangeLabel);
        codeManager.emitException(Framework::getInstance().freshString("Error out of set range. Op: " + currentRelop));

        //  in range
        codeManager.emitLabel(inRangeLabel);
    }

    string storeReg(const string& reg, bool isSet){
        string result = "";
        if (!isSet){
            result = Framework::getInstance().freshVar("i32");
            codeManager.emitStore(reg, result);
        }
        else{
            result = Framework::getInstance().freshVar(SET_def);
            codeManager.emitStoreSet(reg, result);
        }
        return result;
    }

    string storeOverwriteReg(const string& newVal, const string& overwriteLoc,  bool isSet){
        string result = "";
        if (!isSet){
            codeManager.emitStore(newVal, overwriteLoc);
        }
        else{
            codeManager.emitStoreSet(newVal, overwriteLoc);
        }
        return result;
    }

    string loadFromPtr(const string& ptr, bool isSet){
        string result = Framework::getInstance().freshTemp();
        if (!isSet) {
            codeManager.emitLoad(ptr, result);
        }
        else{
            codeManager.emitLoadSet(ptr, result);
        }
        return result;
    }

    string byteTruncated(const string& regToTruncate){
        string result = Framework::getInstance().freshTemp();
        codeManager.emit(result + " = urem i32 " + regToTruncate + ", 256");
        return result;
    }

	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{
    public:
        RetType(const string& type) : NonTerminal("", type) {}

    };
    class Formals : public NonTerminal{
        public:
        list<Variable> namesAndTypes;
        Formals(list<Variable>& namesAndTypes) : NonTerminal("FORMALS", "FORMALS"), namesAndTypes(namesAndTypes) {
            this->namesAndTypes = namesAndTypes;
        }
    };
    class FormalsList : public NonTerminal{
        public:
            list<Variable> namesAndTypes;
            FormalsList(const string& name, const string& type) : NonTerminal("FORMALS LIST", "FORMALS LIST") {
                namesAndTypes.push_back(Variable(name, type));
            }

    };
	class FormalDecl : public NonTerminal{
	public:
	    FormalDecl(const string& name, const string& type) : NonTerminal(name, type) {this->name = name; this->type = type;}
	};
    class Statements : public NonTerminal{
    public:
        Statements(const string& type): NonTerminal("", type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): NonTerminal("", type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): NonTerminal("", type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{
	public:
	    Call(const string& name, const string& type) : NonTerminal(name, type){}

	};
	class ExpList : public NonTerminal{
	    public:
	    ExpList() : NonTerminal("", "")  {}
	};
    class Type : public NonTerminal{
        public:
        Type(const string& type) : NonTerminal("", type) {this->type = type;}
    };
    class Exp : public NonTerminal{
        public:
        Exp(const string& type) : NonTerminal("", type) {}
    };

    static string typeBinopAddChecking(string type1, string type2){
        if ((type1 != "SET" && type1 != "INT" && type1 != "BYTE") ||
            (type2 != "SET" && type2 != "INT" && type2 != "BYTE")) {
            output::errorMismatch(yylineno);
            myExit();
        }
        if(
            ((type1 == "SET" && type2 == "BYTE") || (type1 == "SET" && type2 == "INT")) ||
            ((type2 == "SET" && type1 == "BYTE") || (type2 == "SET" && type1 == "INT"))){
            return "SET";
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        if(type1 == "BYTE" || type2 == "BYTE"){
            return "BYTE";
        }

        output::errorMismatch(yylineno);
        myExit();
    }

    string typeBinopMultiplicativeChecking(string type1, string type2){
        if(type1 == "SET" || type2 == "SET"){
            output::errorMismatch(yylineno);
            myExit();
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        return "BYTE";
    }

    void assignTypeCheck(const string& accepting_type, const string& entering_type){
        if(accepting_type == entering_type){
            return;
        }
        if(accepting_type == "INT" && entering_type == "BYTE"){
            return;
        }
        output::errorMismatch(yylineno);
        myExit();
    }

    bool isAssignTypeCheck(const string& accepting_type, const string& entering_type){
            if(accepting_type == entering_type){
                return true;
            }
            if(accepting_type == "INT" && entering_type == "BYTE"){
                return true;
            }
            return false;
        }

    bool listInsertable(const list<string>& param_list, const list<string>& arg_list){
        if (param_list.size() != arg_list.size()) return false;

        std::list<std::string>::const_iterator param_iter = param_list.cbegin();
        std::list<std::string>::const_iterator arg_iter = arg_list.cbegin();

        for (int i = 0; i<param_list.size(); ++i){
           if (!isAssignTypeCheck(*param_iter, *arg_iter)) return false;
            ++param_iter;
            ++arg_iter;
        }
        return true;
    }

    string fancTypeToLlvmType(const string& fancType){
        if (fancType == "STRING"){
            return "i8* ";
        }
        else if (fancType == "SET"){
            return SET_def + " ";
        }
        else if (fancType == "VOID"){
            return "void ";
        }
        else{
            return "i32 ";
        }
    }
    string placesListToString(const list<string>& places_list, const list<string>& args_list){
        string result = "";
        std::list<std::string>::const_iterator arg_list_it = args_list.cbegin();
        std::list<std::string>::const_iterator place_list_it = places_list.cbegin() ;
        while(arg_list_it != args_list.cend()){
            result += ", ";
            result += fancTypeToLlvmType(*arg_list_it);
            result += *place_list_it + " ";
            ++arg_list_it;
            ++place_list_it;
        }
        return result.substr(2);
    }
%}

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUALITY
%left IN_RELOP
%nonassoc RELOP_RELATIONAL
%left BINOP_ADDITIVE
%left BINOP_MULTIPLICATIVE
%right NOT
%left SC RPAREN RBRACE RBRACKET
%right LBRACE LPAREN LBRACKET

%right COMMA
%right WHILE
%right IF
%right ELSE
%nonassoc TRUE FALSE RETURN BREAK CONTINUE DOTS ID NUM STRING SET INT BYTE B BOOL VOID

%%
// TODO: add ret even if return not given

Program:		Funcs {
                    assert($1.nextList.empty());
                };
Funcs:			/*epsilon*/ {}
                    |FuncDecl Funcs {
                        assert ($1.nextList.empty() && $2.nextList.empty());
                    };
FuncDecl:		RetType
                ID {
                    Framework::getInstance().addScope(Scope::FUNCTION);
                    Framework::getInstance().addFunction(Function($2.name,$1.type));
                }
                LPAREN
                Formals {
                    int numParamsAddedSoFar = 0;
                    for (const Variable& param : $5.namesAndTypes){
                        Framework::getInstance().addParamToLastFunc(param);

                        ++numParamsAddedSoFar;
                        Variable offsetFixedParam = Variable(
                            param.name,
                            param.type,
                            -numParamsAddedSoFar,
                            "%" + to_string(numParamsAddedSoFar - 1)
                        );
                        Framework::getInstance().insertVariableIntoTopScope(offsetFixedParam);
                    }
                }
                RPAREN
                LBRACE {
                    string retType = fancTypeToLlvmType($1.type);
                    string params = "";
                    if (! $5.namesAndTypes.empty()){
                        for (const Variable& param : $5.namesAndTypes){
                            params += string(", ") + retType;
                        }
                        params = params.substr(2);
                    }
                    codeManager.emitFuncOpen($2.name, retType, params);
                    for (const Variable& param : $5.namesAndTypes){
                        string& paramReg = dynamic_cast<Variable&>(Framework::getInstance()[param.name]).LLVM_register;
                        paramReg = storeReg(paramReg, param.type == "SET");
                    }
                }
                Statements
                RBRACE {
                    string retType = fancTypeToLlvmType($1.type);
                    codeManager.emitFuncClose(retType);
                    Framework::getInstance().popScope();

                    assert($10.nextList.empty());
                };
RetType:		Type {$$ = RetType($1.type);}
                    | VOID {$$ = RetType("VOID");};
Formals:		/*epsilon*/ {}
                    | FormalsList {
                        Formals formals = Formals($1.namesAndTypes);
                        $$ = formals;
                        $$.namesAndTypes = formals.namesAndTypes;
                    } ;
FormalsList:	FormalDecl {
                    FormalsList formalsList = FormalsList($1.name, $1.type);
                    $$ = formalsList;
                    $$.namesAndTypes = formalsList.namesAndTypes;
                }
                    | FormalDecl COMMA FormalsList{$$ = $3; $$.namesAndTypes.push_front(Variable($1.name, $1.type));} ;
FormalDecl:		Type ID {$$ = FormalDecl($2.name, $1.type);} ;
Statements:		Statement {
                    $$ = Statements($1.type);

                    $$.nextList = $1.nextList;
                    $$.falseList = $1.falseList;
                    $$.trueList = $1.trueList;
                }
                    | Statements {
                        string nextLabel = Framework::getInstance().freshLabel("statementsNext");
                        codeManager.emitJmp(nextLabel);
                        codeManager.emitLabel(nextLabel);
                        $$.label = nextLabel;
                    }
                    Statement {
                        string& nextLabel = $2.label;
                        codeManager.bpatch($1.nextList, nextLabel);
                        $$.nextList = $3.nextList;
                        $$.falseList = codeManager.merge($3.falseList, $1.falseList);
                        $$.trueList = codeManager.merge($3.trueList, $1.trueList);
                    } ; // DONE: backpatch
Statement:		LBRACE {Framework::getInstance().addScope(Scope::BLOCK);}
                Statements {Framework::getInstance().popScope();}
                RBRACE {
                    $$.nextList = $3.nextList;
                    $$.falseList = $3.falseList;
                    $$.trueList = $3.trueList;
                }
                    | Type ID SC {
                        Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));

                        //initialize new variable
                        string initReg = Framework::getInstance().freshTemp();
                        if ($1.type != "SET"){
                            codeManager.emitTransfer("0", initReg);
                        }
                        else{
                            codeManager.emitNewSet($1.setBegin, $1.setEnd, initReg);
                        }
                        dynamic_cast<Variable&>(Framework::getInstance()[$2.name]).LLVM_register = storeReg(initReg, $1.type == "SET");
                    }
                    | Type ID ASSIGN Exp SC {
                        Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));
                        assignTypeCheck($1.type,$4.type);

                        if ($4.type == "BOOL") insertBoolIntoRegister($4);
                        dynamic_cast<Variable&>(Framework::getInstance()[$2.name]).LLVM_register = storeReg($4.place, $4.type == "SET");
                    }
                    | ID ASSIGN Exp SC {
                        string accepting_type = Framework::getInstance()[$1.name].type;
                        assignTypeCheck(accepting_type, $3.type);
                        if (Framework::getInstance().isFunction($1.name)){
                            output::errorUndef(yylineno, $1.name);
                            myExit();
                        }

                        if ($3.type == "BOOL") insertBoolIntoRegister($3);
                        storeOverwriteReg(
                            $3.place,
                            dynamic_cast<Variable&>(Framework::getInstance()[$1.name]).LLVM_register,
                            $3.type == "SET"
                        );
                    }

                    | Call SC {}
                    | RETURN SC {
                        const string& last_function_type = Framework::getInstance().getLastAddedFunction().type;
                        if(last_function_type!="VOID"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                        $$ = Statement("VOID");

                        codeManager.emit("ret void");
                    }
                    | RETURN Exp SC {
                        const string& last_function_type = Framework::getInstance().getLastAddedFunction().type;
                        assignTypeCheck(last_function_type, $2.type);
                        $$ = Statement($2.type);
                        codeManager.emit("ret " + fancTypeToLlvmType($2.type) + " " + $2.place);

                    }

                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT {
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }

                        string& enterIfCodeLabel = $5.label;
                        $$.nextList = codeManager.merge($3.falseList, $6.nextList);
                        $$.falseList = $6.falseList;
                        $$.trueList = $6.trueList;
                        codeManager.bpatch($3.trueList, enterIfCodeLabel);
                    }
                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT
                    ELSE {
                        Framework::getInstance().addScope(Scope::IF);

                        // Exp condition fulfilled, relevant code executed, now jump past else code
                        $$.nextList = codeManager.makelist(codeManager.emitBpatchJmp());

                        string enterElseCodeLabel = Framework::getInstance().freshLabel("enterElseCode");
                        codeManager.emitLabel(enterElseCodeLabel);
                        $$.label = enterElseCodeLabel;
                    }
                    Statement {
                        Framework::getInstance().popScope();
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }

                        string& enterIfCodeLabel = $5.label;
                        string& enterElseCodeLabel = $9.label;
                        $$.nextList = codeManager.merge(codeManager.merge($6.nextList, $10.nextList), $9.nextList);
                        codeManager.bpatch($3.trueList, enterIfCodeLabel);
                        codeManager.bpatch($3.falseList, enterElseCodeLabel);

                        $$.trueList = codeManager.merge($6.trueList, $10.trueList);
                        $$.falseList = codeManager.merge($6.falseList, $10.falseList);
                    } // DONE: generate jump code, request backpatching
                    | WHILE LPAREN {
                        string loopLabel = Framework::getInstance().freshLabel("loop");
                        codeManager.emitJmp(loopLabel);
                        codeManager.emitLabel(loopLabel);
                        $$.label = loopLabel;
                    }
                    Exp
                    RPAREN {
                        Framework::getInstance().addScope(Scope::LOOP); isInWhile = true;

                        string enterLoopCodeLabel = Framework::getInstance().freshLabel("enterLoopCode");
                        codeManager.emitJmp(enterLoopCodeLabel);
                        codeManager.emitLabel(enterLoopCodeLabel);
                        $$.label = enterLoopCodeLabel;
                    }
                    Statement {
                        Framework::getInstance().popScope();
                        isInWhile = false;
                    } {
                        if ($4.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        } // DONE: generate jump code, request backpatching

                        string& loopLabel = $3.label;
                        string& enterLoopCodeLabel = $6.label;
                        codeManager.bpatch($7.nextList, loopLabel);
                        codeManager.emitJmp(loopLabel);
                        // request backpatch of nextList into Statement's falseList for the sake of Break statements
                        $$.nextList = codeManager.merge($4.falseList, $7.falseList);
                        // backpatch Statement's trueList directing it to the beginning of the loop
                        //  for the sake of Continue statements
                        codeManager.bpatch($7.trueList, loopLabel);
                        codeManager.bpatch($4.trueList, enterLoopCodeLabel);
                    }
                    | BREAK SC{
                        if(!isInWhile){
                             output::errorUnexpectedBreak(yylineno);
                             myExit();
                        }

                        $$.falseList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
                    | CONTINUE SC{
                        if(!isInWhile){
                            output::errorUnexpectedContinue(yylineno);
                            myExit();
                        }

                        $$.trueList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
Call:			ID
                LPAREN
                ExpList
                RPAREN {
                        try{
                            string type = Framework::getInstance()[$1.name].type;
                            if (!Framework::getInstance().isFunction($1.name)) throw Exceptions::IdentifierDoesNotExistException(yylineno, $1.name);

                            if(!listInsertable(varsListToTypesList(dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters()), $3.arrguments_list)){
                                list<Variable> params = dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters();
                                const std::list<string> typesList = varsListToTypesList(params);
                                vector<string> argTypes = vector<string>(typesList.begin(), typesList.end());
                                output::errorPrototypeMismatch(yylineno, $1.name, argTypes);
                                myExit();
                            }
                            $$ = Call ($1.name, type);

                            string argument_list = placesListToString($3.places_list, $3.arrguments_list);
                            string operand = Framework::getInstance().freshTemp();
                            string return_type;
                            if (type == "VOID"){
                                return_type = "void";
                                codeManager.emit("call " + return_type + " @" + $1.name + "(" + argument_list + ")");
                            }
                            else{
                                return_type = fancTypeToLlvmType($1.type);
                                codeManager.emit(operand + " = call " + return_type + " @" + $1.name + "(" + argument_list + ")");
                                $$.place = operand;
                            }

                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    }
                    | ID LPAREN RPAREN {

                        try{
                               string type = Framework::getInstance()[$1.name].type;
                               if (!Framework::getInstance().isFunction($1.name)) throw Exceptions::IdentifierDoesNotExistException(yylineno, $1.name);

                               $$ = Call ($1.name, type);
                               string return_type = fancTypeToLlvmType($1.type);
                               codeManager.emit("call " + return_type + " @" + $1.name + "()");
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    };
ExpList:		Exp {   $$ = ExpList();
                        $$.arrguments_list.push_front($1.type);
                        $$.places_list.push_front($1.place);
                     }
                    | Exp COMMA ExpList {
                        $$ = $3;
                        $$.arrguments_list.push_front($1.type);
                        $$.places_list.push_front($1.place);

                    }
Type:			INT {$$ = Type("INT");}
                    | BYTE{$$ =  Type("BYTE");}
                    | BOOL {$$ =  Type("BOOL");}
                    | SET LBRACKET NUM {$$ = Type("SET"); $3.name = yylval.name; } DOTS NUM RBRACKET {
                        isSetSize($3.name, yylval.name);
                        $$ = Type("SET");

                        $$.setBegin = $3.name;
                        $$.setEnd = $6.name;
                    };

Exp:			LPAREN Exp RPAREN {
                    $$ =  Exp($2.type);

                    $$.place = $2.place;
                }
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1.type, $3.type);
                        $$ = Exp(res_type);

                        string operation = ($2.name == "+")? "add" : "sub";
                        if ($1.type != "SET" && $3.type != "SET"){
                            string operand1 = $1.place;
                            string operand2 = $3.place;
                            string addResult = Framework::getInstance().freshTemp();
                            codeManager.emitBinop(operand1, operand2, addResult, operation);
                            $$.place = (res_type == "BYTE")? byteTruncated(addResult) : addResult;
                        }
                        else{
                            string operandNum = ($1.type != "SET")? $1.place : $3.place;
                            string operandSet = ($1.type == "SET")? $1.place : $3.place;

                            //check within range
                            checkInRange(operandSet, operandNum, $2.name);

                            //extract setArray from set into register
                            string setArray = Framework::getInstance().freshTemp();
                            codeManager.emit(setArray + " = extractvalue " + SET_def + " " + operandSet + ", 3");

                            //store setArray in memory
                            string arrInMemPtr = Framework::getInstance().freshTemp();
                            codeManager.emit(arrInMemPtr + " = alloca " + SETARRAY_def);
                            codeManager.emit("store " + SETARRAY_def + " " + setArray + ", " + SETARRAY_def + "* " + arrInMemPtr);

                            //NEXT 2 BLOCKS: calculate index
                            //get lower bound of set
                            string setBegin = Framework::getInstance().freshTemp();
                            codeManager.emitSetExtractBegin(operandSet, setBegin);

                            //get index of bit that indicates if requested number is in set
                            string arrayIndex = Framework::getInstance().freshTemp();
                            codeManager.emitBinop(operandNum, setBegin, arrayIndex, "sub");

                            //get ptr to requested cell
                            string locationPtr = Framework::getInstance().freshTemp();
                            codeManager.emit(locationPtr + " = getelementptr " + SETARRAY_def + ", " + SETARRAY_def + "* " + arrInMemPtr +
                                ", i1 0, i32 " + arrayIndex);

                            //edit memory at cell requested
                            string newInclusionStatus = ($2.name == "+")? "i1 1" : "i1 0";
                            codeManager.emit("store " + newInclusionStatus + ", i1* " + locationPtr);

                            //load setArray back from memory into register
                            string newSetArray = Framework::getInstance().freshTemp();
                            codeManager.emit(newSetArray + " = load " + SETARRAY_def + ", " + SETARRAY_def + "* " + arrInMemPtr + ", align 4");

                            //insert setArray back from register into set
                            string newSet = Framework::getInstance().freshTemp();
                            codeManager.emit(newSet + " = insertvalue " + SET_def + " " + operandSet +
                                ", " + SETARRAY_def + " " + newSetArray + ", 3");

                            //update set size
                            string oldSetSize = Framework::getInstance().freshTemp();
                            codeManager.emitSetExtractNumElems(operandSet, oldSetSize);
                            string newSetSize = Framework::getInstance().freshTemp();
                            codeManager.emitBinop(oldSetSize, "1", newSetSize, operation);
                            string sizeUpdatedNewSet = Framework::getInstance().freshTemp();
                            codeManager.emit(sizeUpdatedNewSet + " = insertvalue " + SET_def + " " + newSet + ", i32 " + newSetSize + ", 2");

                            //update operandSet.place
                            $$.place = sizeUpdatedNewSet;
                        }
                    }
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1.type, $3.type);
                        $$ = Exp(res_type);

                        // load operands
                        string operation = ($2.name == "*")? "mul" : ($2.name == "/")? "sdiv" : "srem"; //srem = % (modulo)
                        string operand1 = $1.place;
                        string operand2 = $3.place;

                        // division by 0 error check
                        if ($2.name == "/" || $2.name == "%"){
                            string boolZeroEquality = Framework::getInstance().freshTemp();
                            codeManager.emitCond("eq", operand2, "0", boolZeroEquality);
                            string divisionBy0ErrorLabel = Framework::getInstance().freshLabel("divisionBy0Error");
                            string noDivisionBy0Label = Framework::getInstance().freshLabel("noDivisionBy0Error");
                            codeManager.emitIf(boolZeroEquality, divisionBy0ErrorLabel, noDivisionBy0Label);

                            codeManager.emitLabel(divisionBy0ErrorLabel);
                            string errStr = Framework::getInstance().freshString("Error division by zero");
                            //string errStrPtr = Framework::getInstance().freshTemp();
                            //codeManager.emit(errStrPtr + " = getelementptr [24 x i8], [24 x i8]* " + errStr + ", i32 0, i32 0");
                            codeManager.emitException(errStr);
                            codeManager.emitJmp(noDivisionBy0Label);
                            codeManager.emitLabel(noDivisionBy0Label);
                        }

                        // perform multiplication
                        string multResult = Framework::getInstance().freshTemp();
                        codeManager.emitBinop(operand1, operand2, multResult, operation);
                        $$.place = (res_type == "BYTE")? byteTruncated(multResult) : multResult;
                    }
                    | ID {
                        try{
                            $$ =  Exp(Framework::getInstance()[$1.name].type);
                            if (Framework::getInstance().isFunction($1.name)){
                                output::errorUndef(yylineno, $1.name);
                                myExit();
                            }
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndef(yylineno, $1.name);
                            myExit();
                        }

                        const string& type = Framework::getInstance()[$1.name].type;
                        const string& val = loadFromPtr(
                            dynamic_cast<Variable&>(Framework::getInstance()[$1.name]).LLVM_register,
                            type == "SET"
                        );
                        if (type != "BOOL"){
                            $$.place = val;
                        }
                        else{
                            pair<bpatch_address, bpatch_address> bpatchRequests = compare(val, "1", "eq");
                            $$.trueList = codeManager.makelist(bpatchRequests.first);
                            $$.falseList = codeManager.makelist(bpatchRequests.second);
                        }
                    }
                    | Call {
                        $$ =  Exp($1.type);

                        $$.place = $1.place;
                    }
                    | NUM {
                        $$ = Exp("INT");

                        string location = Framework::getInstance().freshTemp();
                        codeManager.emitTransfer($1.name, location);
                        $$.place = location;
                    }
                    | NUM B {
                        if (!isByteSize($1.name)){
                            output::errorByteTooLarge(yylineno, $1.name);
                            myExit();
                        }
                        $$ =  Exp("BYTE");

                        string location = Framework::getInstance().freshTemp();
                        codeManager.emitTransfer($1.name, location);
                        $$.place = location;
                    }
                    | STRING {
                        $$ = Exp("STRING");

                        string txt = $1.name;
                        string location = Framework::getInstance().freshString(txt.substr(1, txt.length()-2));
                        $$.place = location;
                    }
                    | TRUE {
                        $$ =  Exp("BOOL");

                        $$.trueList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
                    | FALSE {
                        $$ =  Exp("BOOL");

                        $$.falseList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
                    | NOT Exp {
                        if($2.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }

                        $$.falseList = $2.trueList;
                        $$.trueList = $2.falseList;
                    }
                    | Exp
                    AND {
                        string eval2ndExpLabel = Framework::getInstance().freshLabel("eval2ndExp");
                        codeManager.emitLabel(eval2ndExpLabel);
                        $$.label = eval2ndExpLabel;
                    }
                    Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }

                        string& eval2ndExpLabel = $3.label;
                        $$.falseList = codeManager.merge($1.falseList, $4.falseList);
                        $$.trueList = $4.trueList;
                        codeManager.bpatch($1.trueList, eval2ndExpLabel);
                    }
                    | Exp
                    OR {
                        string eval2ndExpLabel = Framework::getInstance().freshLabel("eval2ndExp");
                        codeManager.emitLabel(eval2ndExpLabel);
                        $2.name = eval2ndExpLabel;
                    }
                    Exp{
                        if($1.type != "BOOL" || $4.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                           $$ =  Exp("BOOL");
                        }

                        string& eval2ndExpLabel = $2.name;
                        $$.trueList = codeManager.merge($1.trueList, $4.trueList);
                        $$.falseList = $4.falseList;
                        codeManager.bpatch($1.falseList, eval2ndExpLabel);
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        //select operation
                        string operation = "YIKES";
                        if ($2.name == ">") operation = "sgt";
                        if ($2.name == "<") operation = "slt";
                        if ($2.name == ">=") operation = "sge";
                        if ($2.name == "<=") operation = "sle";

                        pair<bpatch_address, bpatch_address> bpatchRequests = compare($1.place, $3.place, operation);
                        $$.trueList = codeManager.makelist(bpatchRequests.first);
                        $$.falseList = codeManager.makelist(bpatchRequests.second);
                    }
                    |Exp IN_RELOP Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "SET")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        // load operands
                        string operandNum = $1.place;
                        string operandSet = $3.place;

                        checkInRange(operandSet, operandNum, "in");

                        //----------check if in set----------
                        //get array from set
                        string setArray = Framework::getInstance().freshTemp();
                        codeManager.emit(setArray + " = extractvalue " + SET_def + " " + operandSet + ", 3");

                        //get lower bound of set
                        string setBegin = Framework::getInstance().freshTemp();
                        codeManager.emitSetExtractBegin(operandSet, setBegin);

                        //get index of bit that indicates if requested number is in set
                        string arrayIndex = Framework::getInstance().freshTemp();
                        codeManager.emitBinop(operandNum, setBegin, arrayIndex, "sub");

                        //push array into memory so that we can extract a bit from it.  locationPtr points to bit
                        string arrInMemPtr = Framework::getInstance().freshTemp();
                        codeManager.emit(arrInMemPtr + " = alloca " + SETARRAY_def);
                        codeManager.emit("store " + SETARRAY_def + " " + setArray + ", " + SETARRAY_def + "* " + arrInMemPtr);
                        string locationPtr = Framework::getInstance().freshTemp();
                        codeManager.emit(locationPtr + " = getelementptr " + SETARRAY_def + ", " + SETARRAY_def + "* " + arrInMemPtr +
                            ", i1 0, i32 " + arrayIndex);

                        //extract bit from locationPtr
                        string boolInclusion = Framework::getInstance().freshTemp();
                        codeManager.emit(boolInclusion + " = load i1, i1* " + locationPtr); //load i1

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitBpatchIf(boolInclusion);
                        $$.trueList.push_back(bpatchRequests.first);
                        $$.falseList.push_back(bpatchRequests.second);
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        //load operands
                        string operation = ($2.name == "==")? "eq" : "ne";
                        string operand1 = $1.place;
                        string operand2 = $3.place;

                        //test for (in)equality
                        string boolEquality = Framework::getInstance().freshTemp();
                        codeManager.emitCond(operation, operand1, operand2, boolEquality);

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitBpatchIf(boolEquality);
                        $$.trueList.push_back(bpatchRequests.first);
                        $$.falseList.push_back(bpatchRequests.second);
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("INT");
                        }

                        string& setPtr = $4.place;
                        $$.place = Framework::getInstance().freshTemp();
                        codeManager.emitSetExtractNumElems(setPtr, $$.place);
                    };
marker_RPAREN:      /*epsilon*/ {
    Framework::getInstance().addScope(Scope::IF);

    string enterIfCodeLabel = Framework::getInstance().freshLabel("enterIfCode");
    codeManager.emitLabel(enterIfCodeLabel);
    $$.label = enterIfCodeLabel;
}
marker_STATEMENT:   /*epsilon*/ {Framework::getInstance().popScope();}

%%

void yyerror(const char*){
	output::errorSyn(yylineno);
	myExit();
}

int main(){
    try{
        // declare externs
        codeManager.emitGlobal( "declare void @exit(i32)" );
        codeManager.emitGlobal( "declare i32 @printf(i8*, ...)" );
        codeManager.emitGlobal(""); // empty line

        // function printi definition:
        codeManager.emitGlobal("@.int_specifier = internal constant [4 x i8] c\"%d\\0A\\00\"");
        codeManager.emitGlobal(
                string("define void @printi(i32) {call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], ") +
                "[4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0) ret void}"
        );
        codeManager.emitGlobal(""); // empty line
        //function print definition:
        codeManager.emitGlobal("@.str_specifier = internal constant [3 x i8] c\"%s\\00\"");
        codeManager.emitGlobal(
                string("define void @print(i8*) {call i32 (i8*, ...) @printf(i8* getelementptr ([3 x i8], ") +
                "[3 x i8]* @.str_specifier, i32 0, i32 0), i8* %0) ret void}"
        );
        codeManager.emitGlobal(""); // empty line

        yyparse();
    }
    catch (const Exceptions::AlreadyExistsException& e){
        output::errorDef(yylineno, e.name);
        myExit();
    }
    catch (const Exceptions::IdentifierDoesNotExistException& e){
        output::errorUndef(yylineno, e.name);
        myExit();
    }

    bool mainExists = false;
    for (const Function& func : Framework::getInstance().functions){
        if (func.name == "main" && func.type == "VOID" && func.getParameters().empty()) mainExists = true;
    }
    if (!mainExists){
        output::errorMainMissing();
        myExit();
    }

    codeManager.printGlobalBuffer();
    cout << endl;
    codeManager.printCodeBuffer();
}