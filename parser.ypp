%{
	#include <iostream>
	#include <string>
	#include <list>
	#include <cassert>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"
	#include "Exceptions.h"
    #include "source.h"
    #include "bp.hpp"

    #define YYSTYPE NonTerminal
    extern list<string> varsListToTypesList(const list<Variable>& varList);

    extern int yylineno;
    int yylex();
    void yyerror(const char*);
    bool isInWhile = false;

    CodeBuffer& codeManager = CodeBuffer::instance();

    void myExit(){
         Framework::getInstance().exitOnError = true;
         exit(0);
    }

    bool isByteSize(string& val){
        int dec_val = std::stoi(val);
        if (dec_val <=255 && dec_val >= 0){
            return true;
        }
        return false;
    }

    void isSetSize(const string& first_num_string, const string& second_num_string){
            int first_num = std::stoi(first_num_string);
            int second_num = std::stoi(second_num_string);
            if (second_num - first_num > 255 || second_num - first_num <= 0){
                output::errorSetTooLarge(yylineno, first_num_string, second_num_string);
                myExit();
            }
        }



	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{
    public:
        RetType(const string& type) : NonTerminal("", type) {}

    };
    class Formals : public NonTerminal{
        public:
        list<Variable> namesAndTypes;
        Formals(list<Variable>& namesAndTypes) : NonTerminal("FORMALS", "FORMALS"), namesAndTypes(namesAndTypes) {
            this->namesAndTypes = namesAndTypes;
        }
    };
    class FormalsList : public NonTerminal{
        public:
            list<Variable> namesAndTypes;
            FormalsList(const string& name, const string& type) : NonTerminal("FORMALS LIST", "FORMALS LIST") {
                namesAndTypes.push_back(Variable(name, type));
            }

    };
	class FormalDecl : public NonTerminal{
	public:
	    FormalDecl(const string& name, const string& type) : NonTerminal(name, type) {this->name = name; this->type = type;}
	};
    class Statements : public NonTerminal{
    public:
        Statements(const string& type): NonTerminal("", type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): NonTerminal("", type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): NonTerminal("", type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{
	public:
	    Call(const string& name, const string& type) : NonTerminal(name, type){}

	};
	class ExpList : public NonTerminal{
	    public:
	    ExpList() : NonTerminal("", "")  {}
	};
    class Type : public NonTerminal{
        public:
        Type(const string& type) : NonTerminal("", type) {this->type = type;}
    };
    class Exp : public NonTerminal{
        public:
        Exp(const string& type) : NonTerminal("", type) {}
    };

    static string typeBinopAddChecking(string type1, string type2){
        if(
            ((type1 == "SET" && type2 == "BYTE") || (type1 == "SET" && type2 == "INT")) ||
            ((type2 == "SET" && type1 == "BYTE") || (type2 == "SET" && type1 == "INT"))){
            return "SET";
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        if(type1 == "BYTE" || type2 == "BYTE"){
            return "BYTE";
        }

        output::errorMismatch(yylineno);
        myExit();
    }

    string typeBinopMultiplicativeChecking(string type1, string type2){
        if(type1 == "SET" || type2 == "SET"){
            output::errorMismatch(yylineno);
            myExit();
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        return "BYTE";
    }

    void assignTypeCheck(const string& accepting_type, const string& entering_type){
        if(accepting_type == entering_type){
            return;
        }
        if(accepting_type == "INT" && entering_type == "BYTE"){
            return;
        }
        output::errorMismatch(yylineno);
        myExit();
    }

    bool isAssignTypeCheck(const string& accepting_type, const string& entering_type){
            if(accepting_type == entering_type){
                return true;
            }
            if(accepting_type == "INT" && entering_type == "BYTE"){
                return true;
            }
            return false;
        }

    bool listInsertable(const list<string>& param_list, const list<string>& arg_list){
        if (param_list.size() != arg_list.size()) return false;

        std::list<std::string>::const_iterator param_iter = param_list.cbegin();
        std::list<std::string>::const_iterator arg_iter = arg_list.cbegin();

        for (int i = 0; i<param_list.size(); ++i){
           if (!isAssignTypeCheck(*param_iter, *arg_iter)) return false;
            ++param_iter;
            ++arg_iter;
        }
        return true;
    }

    string fancTypeToLlvmType(const string& fancType){
        if (fancType == "STRING"){
            return "i8* ";
        }
        else if (fancType == "SET"){
            return "[256 x i1] ";
        }
        else if (fancType == "VOID"){
            return "void ";
        }
        else{
            return "i32 ";
        }
    }
    string placesListToString(const list<string>& places_list, const list<string>& args_list){
        string result = "";
        std::list<std::string>::const_iterator arg_list_it = args_list.cbegin();
        std::list<std::string>::const_iterator place_list_it = places_list.cbegin() ;
        while(arg_list_it != args_list.cend()){
            result += ", ";
            result += fancTypeToLlvmType(*arg_list_it);
            result += *place_list_it + " ";
            ++arg_list_it;
            ++place_list_it;
        }
        return result.substr(2);
    }
%}

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUALITY
%left IN_RELOP
%nonassoc RELOP_RELATIONAL
%left BINOP_ADDITIVE
%left BINOP_MULTIPLICATIVE
%right NOT
%left SC RPAREN RBRACE RBRACKET
%right LBRACE LPAREN LBRACKET

%right COMMA
%right WHILE
%right IF
%right ELSE
%nonassoc TRUE FALSE RETURN BREAK CONTINUE DOTS ID NUM STRING SET INT BYTE B BOOL VOID

%%

Program:		Funcs {
                    assert($1.nextList.empty());
                };
Funcs:			/*epsilon*/ {}
                    |FuncDecl Funcs {
                        assert ($1.nextList.empty() && $2.nextList.empty());
                    };
FuncDecl:		RetType
                ID {
                    Framework::getInstance().addScope(Scope::FUNCTION);
                    Framework::getInstance().addFunction(Function($2.name,$1.type));
                }
                LPAREN
                Formals {
                    int numParamsAddedSoFar = 0;
                    for (const Variable& param : $5.namesAndTypes){
                        Framework::getInstance().addParamToLastFunc(param);

                        ++numParamsAddedSoFar;
                        Variable offsetFixedParam = Variable(param.name, param.type,
                            -numParamsAddedSoFar, "%" + to_string(numParamsAddedSoFar - 1)
                        );
                        Framework::getInstance().insertVariableIntoTopScope(offsetFixedParam);
                    }
                }
                RPAREN
                LBRACE {
                    string retType = fancTypeToLlvmType($1.type);
                    string params = "";
                    if (! $5.namesAndTypes.empty()){
                        for (const Variable& param : $5.namesAndTypes){
                            params += string(", ") + retType + param.LLVM_register;
                        }
                        params = params.substr(2);
                    }
                    codeManager.emitFuncOpen($2.name, retType, params);
                }
                Statements
                RBRACE {
                    codeManager.emitFuncClose();
                    Framework::getInstance().popScope();

                    assert($10.nextList.empty());
                };
RetType:		Type {$$ = RetType($1.type);}
                    | VOID {$$ = RetType("VOID");};
Formals:		/*epsilon*/ {}
                    | FormalsList {
                        Formals formals = Formals($1.namesAndTypes);
                        $$ = formals;
                        $$.namesAndTypes = formals.namesAndTypes;
                    } ;
FormalsList:	FormalDecl {
                    FormalsList formalsList = FormalsList($1.name, $1.type);
                    $$ = formalsList;
                    $$.namesAndTypes = formalsList.namesAndTypes;
                }
                    | FormalDecl COMMA FormalsList{$$ = $3; $$.namesAndTypes.push_front(Variable($1.name, $1.type));} ;
FormalDecl:		Type ID {$$ = FormalDecl($2.name, $1.type);} ;
Statements:		Statement {
                    $$ = Statements($1.type);

                    $$.nextList = $1.nextList;
                    $$.falseList = $1.falseList;
                    $$.trueList = $1.trueList;
                }
                    | Statements {
                        string nextLabel = Framework::getInstance().freshLabel("statementsNext");
                        codeManager.emitJmp(nextLabel);
                        codeManager.emitLabel(nextLabel);
                        $$.label = nextLabel;
                    }
                    Statement {
                        string& nextLabel = $2.label;
                        codeManager.bpatch($1.nextList, nextLabel);
                        $$.nextList = $3.nextList;
                        $$.falseList = codeManager.merge($3.falseList, $1.falseList);
                        $$.trueList = codeManager.merge($3.trueList, $1.trueList);
                    } ; // DONE: backpatch
Statement:		LBRACE {Framework::getInstance().addScope(Scope::BLOCK);}
                Statements {Framework::getInstance().popScope();}
                RBRACE {
                    $$.nextList = $3.nextList;
                    $$.falseList = $3.falseList;
                    $$.trueList = $3.trueList;
                }
                    | Type ID SC { Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));}
                    | Type ID ASSIGN Exp SC {
                        Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));
                        assignTypeCheck($1.type,$4.type);

                        dynamic_cast<Variable&>(Framework::getInstance()[$2.name]).LLVM_register = $4.place;
                    } //TODO: update Variable.LLVM_register, call freshTemp, transfer data into register, check if boolean and if so use phi
                    | ID ASSIGN Exp SC {
                        string accepting_type = Framework::getInstance()[$1.name].type;
                        assignTypeCheck(accepting_type, $3.type);
                        if (Framework::getInstance().isFunction($1.name)){
                            output::errorUndef(yylineno, $1.name);
                            myExit();
                        }
                    } //TODO: update Variable.LLVM_register, call freshTemp, transfer data into register, check if boolean and if so use phi

                    | Call SC {}
                    | RETURN SC {
                        const string& last_function_type = Framework::getInstance().getLastAddedFunction().type;
                        if(last_function_type!="VOID"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                        $$ = Statement("VOID");

                        codeManager.emit("ret void");
                    }
                    | RETURN Exp SC {
                        const string& last_function_type = Framework::getInstance().getLastAddedFunction().type;
                        assignTypeCheck(last_function_type, $2.type);
                        $$ = Statement($2.type);
                        codeManager.emit("ret i32 " + $2.place);

                    } // TODO: should this always be i32?

                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT {
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }

                        string& enterIfCodeLabel = $5.label;
                        $$.nextList = codeManager.merge($3.falseList, $6.nextList);
                        $$.falseList = $6.falseList;
                        $$.trueList = $6.trueList;
                        codeManager.bpatch($3.trueList, enterIfCodeLabel);
                    }
                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT
                    ELSE {
                        Framework::getInstance().addScope(Scope::IF);

                        // Exp condition fulfilled, relevant code executed, now jump past else code
                        $$.nextList = codeManager.makelist(codeManager.emitBpatchJmp());

                        string enterElseCodeLabel = Framework::getInstance().freshLabel("enterElseCode");
                        codeManager.emitLabel(enterElseCodeLabel);
                        $$.label = enterElseCodeLabel;
                    }
                    Statement {
                        Framework::getInstance().popScope();
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }

                        string& enterIfCodeLabel = $5.label;
                        string& enterElseCodeLabel = $9.label;
                        $$.nextList = codeManager.merge(codeManager.merge($6.nextList, $10.nextList), $9.nextList);
                        codeManager.bpatch($3.trueList, enterIfCodeLabel);
                        codeManager.bpatch($3.falseList, enterElseCodeLabel);

                        $$.trueList = codeManager.merge($6.trueList, $10.trueList);
                        $$.falseList = codeManager.merge($6.falseList, $10.falseList);
                    } // DONE: generate jump code, request backpatching
                    | WHILE LPAREN {
                        string loopLabel = Framework::getInstance().freshLabel("loop");
                        codeManager.emitJmp(loopLabel);
                        codeManager.emitLabel(loopLabel);
                        $$.label = loopLabel;
                    }
                    Exp
                    RPAREN {
                        Framework::getInstance().addScope(Scope::LOOP); isInWhile = true;

                        string enterLoopCodeLabel = Framework::getInstance().freshLabel("enterLoopCode");
                        codeManager.emitJmp(enterLoopCodeLabel);
                        codeManager.emitLabel(enterLoopCodeLabel);
                        $$.label = enterLoopCodeLabel;
                    }
                    Statement {
                        Framework::getInstance().popScope();
                        isInWhile = false;
                    } {
                        if ($4.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        } // DONE: generate jump code, request backpatching

                        string& loopLabel = $3.label;
                        string& enterLoopCodeLabel = $6.label;
                        codeManager.bpatch($7.nextList, loopLabel);
                        codeManager.emitJmp(loopLabel);
                        // request backpatch of nextList into Statement's falseList for the sake of Break statements
                        $$.nextList = codeManager.merge($4.falseList, $7.falseList);
                        // backpatch Statement's trueList directing it to the beginning of the loop
                        //  for the sake of Continue statements
                        codeManager.bpatch($7.trueList, loopLabel);
                        codeManager.bpatch($4.trueList, enterLoopCodeLabel);
                    }
                    | BREAK SC{
                        if(!isInWhile){
                             output::errorUnexpectedBreak(yylineno);
                             myExit();
                        }

                        $$.falseList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
                    | CONTINUE SC{
                        if(!isInWhile){
                            output::errorUnexpectedContinue(yylineno);
                            myExit();
                        }

                        $$.trueList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
Call:			ID
                LPAREN
                ExpList
                RPAREN {
                        try{
                            string type = Framework::getInstance()[$1.name].type;
                            if (!Framework::getInstance().isFunction($1.name)) throw Exceptions::IdentifierDoesNotExistException(yylineno, $1.name);

                            if(!listInsertable(varsListToTypesList(dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters()), $3.arrguments_list)){
                                list<Variable> params = dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters();
                                const std::list<string> typesList = varsListToTypesList(params);
                                vector<string> argTypes = vector<string>(typesList.begin(), typesList.end());
                                output::errorPrototypeMismatch(yylineno, $1.name, argTypes);
                                myExit();
                            }
                            $$ = Call ($1.name, type);

                            string argument_list = placesListToString($3.places_list, $3.arrguments_list);
                            string operand = Framework::getInstance().freshTemp();
                            string return_type;
                            if (type == "VOID"){
                                return_type = "void";
                                codeManager.emit("call " + return_type + " @" + $1.name + "(" + argument_list + ")");
                            }
                            else{
                                return_type = "i32";
                                codeManager.emit(operand + " = call " + return_type + " @" + $1.name + "(" + argument_list + ")");
                                $$.place = operand;
                            }

                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    } // TODO: generate jump code, request backpatching
                    | ID LPAREN RPAREN {

                        try{
                               string type = Framework::getInstance()[$1.name].type;
                               if (!Framework::getInstance().isFunction($1.name)) throw Exceptions::IdentifierDoesNotExistException(yylineno, $1.name);

                               $$ = Call ($1.name, type);
                               string return_type = "void";
                               codeManager.emit("call " + return_type + " @" + $1.name + "()");
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    }; // TODO: generate jump code, request backpatching
ExpList:		Exp {   $$ = ExpList();
                        $$.arrguments_list.push_front($1.type);
                        $$.places_list.push_front($1.place);
                     } //TODO: call freshVar
                    | Exp COMMA ExpList {
                        $$ = $3;
                        $$.arrguments_list.push_front($1.type);
                        $$.places_list.push_front($1.place);

                    } //TODO: call freshVar
Type:			INT {$$ = Type("INT");}
                    | BYTE{$$ =  Type("BYTE");}
                    | BOOL {$$ =  Type("BOOL");}
                    | SET LBRACKET NUM{$$ = Type("SET"); $3.name = yylval.name; } DOTS NUM RBRACKET {
                        isSetSize($3.name, yylval.name);
                        $$ = Type("SET");
                    };

// TODO: All Exps need freshVar (into Exp.place)
Exp:			LPAREN Exp RPAREN {
                    $$ =  Exp($2.type);

                    $$.place = $2.place;
                }
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1.type, $3.type);
                        $$ = Exp(res_type);

                        string operation = ($2.name == "+")? "add" : "sub";
                        string operand1 = $1.place;
                        string operand2 = $3.place;
                        string addResult = Framework::getInstance().freshTemp();
                        codeManager.emitBinop(operand1, operand2, addResult, operation);
                        $$.place = addResult;
                    }
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1.type, $3.type);
                        $$ = Exp(res_type);

                        // load operands
                        string operation = ($2.name == "*")? "mul" : ($2.name == "/")? "sdiv" : "udiv";
                        string operand1 = $1.place;
                        string operand2 = $3.place;

                        // division by 0 error check
                        if ($2.name == "/" || $2.name == "%"){
                            string boolZeroEquality = Framework::getInstance().freshTemp();
                            codeManager.emitCond("eq", operand2, "0", boolZeroEquality);
                            string divisionBy0ErrorLabel = Framework::getInstance().freshLabel("divisionBy0Error");
                            string noDivisionBy0Label = Framework::getInstance().freshLabel("noDivisionBy0Error");
                            codeManager.emitIf(boolZeroEquality, divisionBy0ErrorLabel, noDivisionBy0Label);

                            codeManager.emitLabel(divisionBy0ErrorLabel);
                            string errStr = Framework::getInstance().freshString("Error division by zero");
                            //string errStrPtr = Framework::getInstance().freshTemp();
                            //codeManager.emit(errStrPtr + " = getelementptr [24 x i8], [24 x i8]* " + errStr + ", i32 0, i32 0");
                            codeManager.emit("call void (i8*) @print(i8* " + errStr + " )");
                            codeManager.emit("call void (i32) @exit(i32 0)");
                            codeManager.emitJmp(noDivisionBy0Label);
                            codeManager.emitLabel(noDivisionBy0Label);
                        }

                        // perform multiplication
                        string multResult = Framework::getInstance().freshTemp();
                        codeManager.emitBinop(operand1, operand2, multResult, operation);
                        $$.place = multResult;
                    }
                    | ID {
                        try{
                            $$ =  Exp(Framework::getInstance()[$1.name].type);
                            if (Framework::getInstance().isFunction($1.name)){
                                output::errorUndef(yylineno, $1.name);
                                myExit();
                            }
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndef(yylineno, $1.name);
                            myExit();
                        }

                        $$.place = dynamic_cast<Variable&>(Framework::getInstance()[$1.name]).LLVM_register;
                    }
                    | Call {
                        $$ =  Exp($1.type);

                        $$.place = $1.place;
                    }
                    | NUM {
                        $$ = Exp("INT");

                        string location = Framework::getInstance().freshTemp();
                        codeManager.emitTransfer($1.name, location);
                        $$.place = location;
                    }
                    | NUM B {
                        if (!isByteSize($1.name)){
                            output::errorByteTooLarge(yylineno, $1.name);
                            myExit();
                        }
                        $$ =  Exp("BYTE");

                        string location = Framework::getInstance().freshTemp();
                        codeManager.emitTransfer($1.name, location);
                        $$.place = location;
                    }
                    | STRING {
                        $$ = Exp("STRING");

                        string txt = $1.name;
                        string location = Framework::getInstance().freshString(txt.substr(1, txt.length()-2));
                        $$.place = location;
                    }
                    | TRUE {
                        $$ =  Exp("BOOL");

                        $$.trueList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
                    | FALSE {
                        $$ =  Exp("BOOL");

                        $$.falseList = codeManager.makelist(codeManager.emitBpatchJmp());
                    }
                    | NOT Exp {
                        if($2.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }

                        $$.falseList = $2.trueList;
                        $$.trueList = $2.falseList;
                    }
                    | Exp
                    AND {
                        string eval2ndExpLabel = Framework::getInstance().freshLabel("eval2ndExp");
                        codeManager.emitLabel(eval2ndExpLabel);
                        $$.label = eval2ndExpLabel;
                    }
                    Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }

                        string& eval2ndExpLabel = $3.label;
                        $$.falseList = codeManager.merge($1.falseList, $4.falseList);
                        $$.trueList = $4.trueList;
                        codeManager.bpatch($1.trueList, eval2ndExpLabel);
                    }
                    | Exp
                    OR {
                        string eval2ndExpLabel = Framework::getInstance().freshLabel("eval2ndExp");
                        codeManager.emitLabel(eval2ndExpLabel);
                        $2.name = eval2ndExpLabel;
                    }
                    Exp{
                        if($1.type != "BOOL" || $4.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                           $$ =  Exp("BOOL");
                        }

                        string& eval2ndExpLabel = $2.name;
                        $$.trueList = codeManager.merge($1.trueList, $4.trueList);
                        $$.falseList = $4.falseList;
                        codeManager.bpatch($1.falseList, eval2ndExpLabel);
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        //select operation
                        string operation = "YIKES";
                        if ($2.name == ">") operation = "sgt";
                        if ($2.name == "<") operation = "slt";
                        if ($2.name == ">=") operation = "sge";
                        if ($2.name == "<=") operation = "sle";

                        //load operands
                        string operand1 = $1.place;
                        string operand2 = $3.place;

                        //test for relation
                        string boolRelation = Framework::getInstance().freshTemp();
                        codeManager.emitCond(operation, operand1, operand2, boolRelation);

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitBpatchIf(boolRelation);
                        $$.trueList = codeManager.makelist(bpatchRequests.first);
                        $$.falseList = codeManager.makelist(bpatchRequests.second);
                    }
                    |Exp IN_RELOP Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "SET")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        // load operands
                        string operand1 = $1.place;
                        string operand2 = $3.place;

                        // TODO: check within range

                        // check if in set
                        string locationPtr = Framework::getInstance().freshTemp();
                        codeManager.emit(locationPtr + " = getelementptr [256 x i1], [256 x i1]* " + operand2 +
                            ", i32 " + operand1 + ", i1 0");
                        string boolInclusion = Framework::getInstance().freshTemp(); //TODO: remove boolean register boolInclusion
                        codeManager.emit(boolInclusion + " = load i1, i1* " + locationPtr); //load i1

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitBpatchIf(boolInclusion);
                        $$.trueList.push_back(bpatchRequests.first);
                        $$.falseList.push_back(bpatchRequests.second);
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        //load operands
                        string operation = ($2.name == "==")? "eq" : "ne";
                        string operand1 = $1.place;
                        string operand2 = $3.place;

                        //test for (in)equality
                        string boolEquality = Framework::getInstance().freshTemp();
                        codeManager.emitCond(operation, operand1, operand2, boolEquality);

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitBpatchIf(boolEquality);
                        $$.trueList.push_back(bpatchRequests.first);
                        $$.falseList.push_back(bpatchRequests.second);
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("INT");
                        }

                        $$.place = $4.place;
                    };
marker_RPAREN:      /*epsilon*/ {
    Framework::getInstance().addScope(Scope::IF);

    string enterIfCodeLabel = Framework::getInstance().freshLabel("enterIfCode");
    codeManager.emitLabel(enterIfCodeLabel);
    $$.label = enterIfCodeLabel;
}
marker_STATEMENT:   /*epsilon*/ {Framework::getInstance().popScope();}

%%

void yyerror(const char*){
	output::errorSyn(yylineno);
	myExit();
}

int main(){
    try{
        // declare externs
        codeManager.emitGlobal( "declare void @exit(i32)" );
        codeManager.emitGlobal( "declare i32 @printf(i8*, ...)" );
        codeManager.emitGlobal(""); // empty line

        // function printi definition:
        codeManager.emitGlobal("@.int_specifier = internal constant [4 x i8] c\"%d\\0A\\00\"");
        codeManager.emitGlobal(
                string("define void @printi(i32) {call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], ") +
                "[4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0) ret void}"
        );
        codeManager.emitGlobal(""); // empty line
        //function print definition:
        codeManager.emitGlobal("@.str_specifier = internal constant [3 x i8] c\"%s\\00\"");
        codeManager.emitGlobal(
                string("define void @print(i8*) {call i32 (i8*, ...) @printf(i8* getelementptr ([3 x i8], ") +
                "[3 x i8]* @.str_specifier, i32 0, i32 0), i8* %0) ret void}"
        );
        codeManager.emitGlobal(""); // empty line

        yyparse();
    }
    catch (const Exceptions::AlreadyExistsException& e){
        output::errorDef(yylineno, e.name);
        myExit();
    }
    catch (const Exceptions::IdentifierDoesNotExistException& e){
        output::errorUndef(yylineno, e.name);
        myExit();
    }

    bool mainExists = false;
    for (const Function& func : Framework::getInstance().functions){
        if (func.name == "main" && func.type == "VOID" && func.getParameters().empty()) mainExists = true;
    }
    if (!mainExists){
        output::errorMainMissing();
        myExit();
    }

    codeManager.printGlobalBuffer();
    codeManager.printCodeBuffer();
}