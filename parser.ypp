%{
	#include <iostream>
	#include <string>
	#include <list>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"
	#include "Exceptions.h"
    #include "source.h"
    #include "bp.hpp"

    #define YYSTYPE NonTerminal
    extern list<string> varsListToTypesList(const list<Variable>& varList);

    extern int yylineno;
    int yylex();
    void yyerror(const char*);
    bool isInWhile = false;

    CodeBuffer& codeManager = CodeBuffer::instance();

    void myExit(){
         Framework::getInstance().exitOnError = true;
         exit(0);
    }

    bool isByteSize(string& val){
        int dec_val = std::stoi(val);
        if (dec_val <=255 && dec_val >= 0){
            return true;
        }
        return false;
    }

    void isSetSize(const string& first_num_string, const string& second_num_string){
            int first_num = std::stoi(first_num_string);
            int second_num = std::stoi(second_num_string);
            if (second_num - first_num > 255 || second_num - first_num <= 0){
                output::errorSetTooLarge(yylineno, first_num_string, second_num_string);
                myExit();
            }
        }



	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{
    public:
        RetType(const string& type) : NonTerminal("", type) {}

    };
    class Formals : public NonTerminal{
        public:
        list<Variable> namesAndTypes;
        Formals(list<Variable>& namesAndTypes) : NonTerminal("FORMALS", "FORMALS"), namesAndTypes(namesAndTypes) {
            this->namesAndTypes = namesAndTypes;
        }
    };
    class FormalsList : public NonTerminal{
        public:
            list<Variable> namesAndTypes;
            FormalsList(const string& name, const string& type) : NonTerminal("FORMALS LIST", "FORMALS LIST") {
                namesAndTypes.push_back(Variable(name, type));
            }

    };
	class FormalDecl : public NonTerminal{
	public:
	    FormalDecl(const string& name, const string& type) : NonTerminal(name, type) {this->name = name; this->type = type;}
	};
    class Statements : public NonTerminal{
    public:
        Statements(const string& type): NonTerminal("", type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): NonTerminal("", type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): NonTerminal("", type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{
	public:
	    Call(const string& name, const string& type) : NonTerminal(name, type){}

	};
	class ExpList : public NonTerminal{
	    public:
	    ExpList() : NonTerminal("", "")  {}
	};
    class Type : public NonTerminal{
        public:
        Type(const string& type) : NonTerminal("", type) {this->type = type;}
    };
    class Exp : public NonTerminal{
        public:
        Exp(const string& type) : NonTerminal("", type) {}
    };

    static string typeBinopAddChecking(string type1, string type2){
        if(
            ((type1 == "SET" && type2 == "BYTE") || (type1 == "SET" && type2 == "INT")) ||
            ((type2 == "SET" && type1 == "BYTE") || (type2 == "SET" && type1 == "INT"))){
            return "SET";
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        if(type1 == "BYTE" || type2 == "BYTE"){
            return "BYTE";
        }

        output::errorMismatch(yylineno);
        myExit();
    }

    string typeBinopMultiplicativeChecking(string type1, string type2){
        if(type1 == "SET" || type2 == "SET"){
            output::errorMismatch(yylineno);
            myExit();
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        return "BYTE";
    }

    void assignTypeCheck(const string& accepting_type, const string& entering_type){
        if(accepting_type == entering_type){
            return;
        }
        if(accepting_type == "INT" && entering_type == "BYTE"){
            return;
        }
        output::errorMismatch(yylineno);
        myExit();
    }

    bool isAssignTypeCheck(const string& accepting_type, const string& entering_type){
            if(accepting_type == entering_type){
                return true;
            }
            if(accepting_type == "INT" && entering_type == "BYTE"){
                return true;
            }
            return false;
        }

    bool listInsertable(const list<string>& param_list, const list<string>& arg_list){
        if (param_list.size() != arg_list.size()) return false;

        std::list<std::string>::const_iterator param_iter = param_list.cbegin();
        std::list<std::string>::const_iterator arg_iter = arg_list.cbegin();

        for (int i = 0; i<param_list.size(); ++i){
           if (!isAssignTypeCheck(*param_iter, *arg_iter)) return false;
            ++param_iter;
            ++arg_iter;
        }
        return true;
    }

    string placesListToString(const list<string>& places_list, const list<string>& args_list){
        string result = "";
        std::list<std::string>::const_iterator arg_list_it = args_list.cbegin();
        std::list<std::string>::const_iterator place_list_it = places_list.cbegin() ;
        while(arg_list_it != args_list.cend()){
            if(*arg_list_it == "STRING"){
                result += "i8* ";
            }
            else if(*arg_list_it == "SET"){
                result += "[256 * i1] ";
            }
            else{
                result += "[i32] ";
            }
            result += *place_list_it + " ";
            ++arg_list_it;
            ++place_list_it;
        }
        return result;
    }
%}

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUALITY
%left IN_RELOP
%nonassoc RELOP_RELATIONAL
%left BINOP_ADDITIVE
%left BINOP_MULTIPLICATIVE
%right NOT
%left SC RPAREN RBRACE RBRACKET
%right LBRACE LPAREN LBRACKET

%right COMMA
%right WHILE
%right IF
%right ELSE
%nonassoc TRUE FALSE RETURN BREAK CONTINUE DOTS ID NUM STRING SET INT BYTE B BOOL VOID

%%

Program:		Funcs {};
Funcs:			/*epsilon*/ {}
                    |FuncDecl Funcs {}; //TODO: backpatch
FuncDecl:		RetType
                ID {
                    Framework::getInstance().addScope(Scope::FUNCTION);
                    Framework::getInstance().addFunction(Function($2.name,$1.type));
                }
                LPAREN
                Formals {
                    int numParamsAddedSoFar = 0;
                    for (const Variable& param : $5.namesAndTypes){
                        Framework::getInstance().addParamToLastFunc(param);

                        ++numParamsAddedSoFar;
                        Variable offsetFixedParam = Variable(param.name, param.type, -numParamsAddedSoFar);
                        Framework::getInstance().insertVariableIntoTopScope(offsetFixedParam);
                    }
                }
                RPAREN
                LBRACE {
                    string retType = ($1.type == "VOID")? "void" : "i32";
                    string params = "";
                    if (!$5.namesAndTypes.empty()) {
                        for (const Variable& param : $5.namesAndTypes){
                            params += string(", ") + param.LLVM_register;
                        }
                        params = params.substr(2);
                    }
                    codeManager.emitFuncOpen($2.name, retType, params);
                }
                Statements
                RBRACE {
                    codeManager.emitFuncClose();
                    Framework::getInstance().popScope();
                };
RetType:		Type {$$ = RetType($1.type);}
                    | VOID {$$ = RetType("VOID");};
Formals:		/*epsilon*/ {}
                    | FormalsList {
                        Formals formals = Formals($1.namesAndTypes);
                        $$ = formals;
                        $$.namesAndTypes = formals.namesAndTypes;
                    } ;
FormalsList:	FormalDecl {
                    FormalsList formalsList = FormalsList($1.name, $1.type);
                    $$ = formalsList;
                    $$.namesAndTypes = formalsList.namesAndTypes;
                }
                    | FormalDecl COMMA FormalsList{$$ = $3; $$.namesAndTypes.push_front(Variable($1.name, $1.type));} ;
FormalDecl:		Type ID {$$ = FormalDecl($2.name, $1.type);} ;
Statements:		Statement {$$ = Statements($1.type);}
                    | Statements Statement{} ; // TODO: backpatch
Statement:		LBRACE {Framework::getInstance().addScope(Scope::BLOCK);}
                Statements {Framework::getInstance().popScope();}
                RBRACE {}
                    | Type ID SC { Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));}
                    | Type ID ASSIGN Exp SC {
                            Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));
                            assignTypeCheck($1.type,$4.type);
                    } //TODO: update Variable.LLVM_register, call freshVar, transfer data into register, check if boolean and if so use phi
                    | ID ASSIGN Exp SC {
                        string accepting_type = Framework::getInstance()[$1.name].type;
                        assignTypeCheck(accepting_type, $3.type);
                        if (Framework::getInstance().isFunction($1.name)){
                            output::errorUndef(yylineno, $1.name);
                            myExit();
                        }
                    } //TODO: update Variable.LLVM_register, call freshVar, transfer data into register, check if boolean and if so use phi

                    | Call SC {}
                    | RETURN SC { // TODO: generate jump code, request backpatching
                        const string& last_function_type = Framework::getInstance().getLastAddedFunction().type;
                        if(last_function_type!="VOID"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                        $$ = Statement("VOID");

                        codeManager.emit("ret void");
                    }
                    | RETURN Exp SC {
                        const string& last_function_type = Framework::getInstance().getLastAddedFunction().type;
                        assignTypeCheck(last_function_type, $2.type);
                        $$ = Statement($2.type);
                        codeManager.emit("ret i32 " + $2.place);

                    } // TODO: generate jump code, request backpatching, transfer data to return zone

                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT {
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                    } // TODO: generate jump code, request backpatching
                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT
                    ELSE {Framework::getInstance().addScope(Scope::IF);}
                    Statement {
                        Framework::getInstance().popScope();
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                    } // TODO: generate jump code, request backpatching
                    | WHILE LPAREN Exp RPAREN {Framework::getInstance().addScope(Scope::LOOP); isInWhile = true;} Statement {Framework::getInstance().popScope(); isInWhile = false;} {
                    if ($3.type != "BOOL"){
                         output::errorMismatch(yylineno);
                         myExit();
                    } // TODO: generate jump code, request backpatching

                    }
                    | BREAK SC{
                        if(!isInWhile){
                             output::errorUnexpectedBreak(yylineno);
                             myExit();
                        }
                    } // TODO: generate jump code, request backpatching
                    | CONTINUE SC{
                        if(!isInWhile){
                            output::errorUnexpectedContinue(yylineno);
                            myExit();
                        }
                    } // TODO: generate jump code, request backpatching
Call:			ID
                LPAREN
                ExpList
                RPAREN {
                        try{
                            string type = Framework::getInstance()[$1.name].type;
                            if (!Framework::getInstance().isFunction($1.name)) throw Exceptions::IdentifierDoesNotExistException(yylineno, $1.name);

                            if(!listInsertable(varsListToTypesList(dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters()), $3.arrguments_list)){
                                list<Variable> params = dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters();
                                const std::list<string> typesList = varsListToTypesList(params);
                                vector<string> argTypes = vector<string>(typesList.begin(), typesList.end());
                                output::errorPrototypeMismatch(yylineno, $1.name, argTypes);
                                myExit();
                            }
                            $$ = Call ($1.name, type);

                            string argument_list = placesListToString($3.places_list, $3.arrguments_list);
                            string operand = Framework::getInstance().freshTemp();
                            string return_type;
                            if (type == "VOID"){
                                return_type = "void";
                                codeManager.emit("call " + return_type + " @" + $1.name + "(" + argument_list + ")");
                            }
                            else{
                                return_type = "i32";
                                codeManager.emit(operand + " = call " + return_type + " @" + $1.name + "(" + argument_list + ")");
                                $$.place = operand;
                            }

                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    } // TODO: generate jump code, request backpatching
                    | ID LPAREN RPAREN {

                        try{
                               string type = Framework::getInstance()[$1.name].type;
                               if (!Framework::getInstance().isFunction($1.name)) throw Exceptions::IdentifierDoesNotExistException(yylineno, $1.name);

                               $$ = Call ($1.name, type);
                               string return_type = "void";
                               codeManager.emit("call " + return_type + " @" + $1.name + "()");
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    }; // TODO: generate jump code, request backpatching
ExpList:		Exp {   $$ = ExpList();
                        $$.arrguments_list.push_front($1.type);
                        $$.places_list.push_front($1.place);
                     } //TODO: call freshVar
                    | Exp COMMA ExpList {
                        $$ = $3;
                        $$.arrguments_list.push_front($1.type);
                        $$.places_list.push_front($1.place);

                    } //TODO: call freshVar
Type:			INT {$$ = Type("INT");}
                    | BYTE{$$ =  Type("BYTE");}
                    | BOOL {$$ =  Type("BOOL");}
                    | SET LBRACKET NUM{$$ = Type("SET"); $3.name = yylval.name; } DOTS NUM RBRACKET {
                        isSetSize($3.name, yylval.name);
                        $$ = Type("SET");
                    };

// TODO: All Exps need freshVar (into Exp.place)
Exp:			LPAREN Exp RPAREN {
                    $$ =  Exp($2.type);

                    $$.place = $2.place;
                }
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1.type, $3.type);
                        $$ = Exp(res_type);

                        string operation = ($2.name == "+")? "add" : "sub";
                        string operand1 = Framework::getInstance().freshTemp();
                        string operand2 = Framework::getInstance().freshTemp();
                        codeManager.emitLoad($1.place, operand1);
                        codeManager.emitLoad($3.place, operand2);
                        string addResult = Framework::getInstance().freshTemp();
                        codeManager.emitBinop(operand1, operand2, addResult, operation);
                        $$.place = Framework::getInstance().freshVar();
                        codeManager.emitStore(addResult, $$.place);
                    }
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1.type, $3.type);
                        $$ = Exp(res_type);

                        // load operands
                        string operation = ($2.name == "*")? "mul" : ($2.name == "/")? "sdiv" : "udiv";
                        string operand1 = Framework::getInstance().freshTemp();
                        string operand2 = Framework::getInstance().freshTemp();
                        codeManager.emitLoad($1.place, operand1);
                        codeManager.emitLoad($3.place, operand2);

                        // division by 0 error check
                        if ($2.name == "/" || $2.name == "%"){
                            string boolZeroEquality = Framework::getInstance().freshTemp();
                            codeManager.emitCond("eq", operand1, "0", boolZeroEquality);
                            string divisionBy0ErrorLabel = Framework::getInstance().freshLabel("divisionBy0Error");
                            string noDivisionBy0Label = Framework::getInstance().freshLabel("noDivisionBy0Error");
                            codeManager.emitIf(boolZeroEquality, divisionBy0ErrorLabel, noDivisionBy0Label);

                            codeManager.emitLabel(divisionBy0ErrorLabel);
                            string errStr = Framework::getInstance().freshString("Error division by zero");
                            string errStrPtr = Framework::getInstance().freshTemp();
                            codeManager.emit(errStrPtr + " = getelementptr [24 x i8], [24 x i8]* @" + errStr + ", i32 0, i32 0");
                            codeManager.emit("call void (i8*) @print(i8* " + errStrPtr + " )");
                            codeManager.emit("call void (i32) @exit(i32 0)");
                            codeManager.emitJmp(noDivisionBy0Label);
                            codeManager.emitLabel(noDivisionBy0Label);
                        }

                        // perform multiplication
                        string multResult = Framework::getInstance().freshTemp();
                        codeManager.emitBinop(operand1, operand2, multResult, operation);
                        $$.place = Framework::getInstance().freshVar();
                        codeManager.emitStore(multResult, $$.place);

                    }
                    | ID {
                            try{
                                $$ =  Exp(Framework::getInstance()[$1.name].type);
                                if (Framework::getInstance().isFunction($1.name)){
                                    output::errorUndef(yylineno, $1.name);
                                    myExit();
                                }
                            }
                            catch(Exceptions::IdentifierDoesNotExistException &e){
                                output::errorUndef(yylineno, $1.name);
                                myExit();
                            }

                            $$.place = dynamic_cast<Variable&>(Framework::getInstance()[$1.name]).LLVM_register;
                    }
                    | Call {
                        $$ =  Exp($1.type);

                        $$.place = $1.place;
                    }
                    | NUM {
                        $$ = Exp("INT");

                        string location = Framework::getInstance().freshVar();
                        codeManager.emitStore($1.name, location);
                        $$.place = location;
                    }
                    | NUM B {
                        if (!isByteSize($1.name)){
                            output::errorByteTooLarge(yylineno, $1.name);
                            myExit();
                        }
                        $$ =  Exp("BYTE");

                        string location = Framework::getInstance().freshVar();
                        codeManager.emitStore($1.name, location);
                        $$.place = location;
                    }
                    | STRING {
                        $$ = Exp("STRING");

                        string txt = $1.name;
                        string location = Framework::getInstance().freshString(txt.substr(1, txt.length()-2));
                        $$.place = location;
                    }
                    | TRUE {
                        $$ =  Exp("BOOL");

                        $$.trueList = codeManager.makelist(codeManager.emitJmp("@"));
                    }
                    | FALSE {
                        $$ =  Exp("BOOL");

                        $$.falseList = codeManager.makelist(codeManager.emitJmp("@"));
                    }
                    | NOT Exp {
                        if($2.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }

                        $$.falseList = $2.trueList;
                        $$.trueList = $2.falseList;
                    }
                    | Exp
                    AND {
                        string& eval2ndExpLabel = Framework::getInstance().freshLabel("eval2ndExp");
                        codeManager.emitLabel(eval2ndExpLabel);
                       // $3.name = eval2ndExpLabel;
                    }
                    Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }

                        string& eval2ndExpLabel = $3.name;
                        $$.falseList = codeManager.merge($1.falseList, $4.falseList);
                        $$.trueList = $4.trueList;
                        codeManager.bpatch($1.trueList, eval2ndExpLabel);
                    }
                    | Exp
                    OR {
                        string& eval2ndExpLabel = Framework::getInstance().freshLabel("eval2ndExp");
                        codeManager.emitLabel(eval2ndExpLabel);
                       // $3.name = eval2ndExpLabel;
                    }
                    Exp{
                        if($1.type != "BOOL" || $4.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                           $$ =  Exp("BOOL");
                        }

                        string& eval2ndExpLabel = $3.name;
                        $$.trueList = codeManager.merge($1.trueList, $4.trueList);
                        $$.falseList = $4.falseList;
                        codeManager.bpatch($1.falseList, eval2ndExpLabel);
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        //select operation
                        string operation = "YIKES";
                        if ($2.name == ">") operation = "sgt";
                        if ($2.name == "<") operation = "slt";
                        if ($2.name == ">=") operation = "sge";
                        if ($2.name == "<=") operation = "sle";

                        //load operands
                        string operand1 = Framework::getInstance().freshTemp();
                        string operand2 = Framework::getInstance().freshTemp();
                        codeManager.emitLoad($1.place, operand1);
                        codeManager.emitLoad($3.place, operand2);

                        //test for relation
                        string boolRelation = Framework::getInstance().freshTemp();
                        codeManager.emitCond(operation, operand1, operand2, boolRelation);

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitIf(boolRelation, "@", "@");
                        $$.trueList = codeManager.makelist(bpatchRequests.first);
                        $$.falseList = codeManager.makelist(bpatchRequests.second);
                    }
                    |Exp IN_RELOP Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "SET")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        // load operands
                        string operand1 = Framework::getInstance().freshTemp();
                        string operand2 = Framework::getInstance().freshTemp();
                        codeManager.emitLoad($1.place, operand1);
                        emit(operand2 + " = load [256 x i1], [256 x i1]* " + $3.place); //load set

                        // TODO: check within range

                        // check if in set
                        string locationPtr = Framework::getInstance().freshTemp();
                        codeManager.emit(locationPtr + " = getelementptr [256 x i1], [256 x i1]* " + operand2 +
                            ", i32 " + operand1 + ", i1 0");
                        string boolInclusion = Framework::getInstance().freshTemp(); //TODO: remove boolean register boolInclusion
                        emit(boolInclusion + " = load i1, i1* " + locationPtr); //load i1

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitIf(boolEquality, "@", "@");
                        $$.trueList.push_back(bpatchRequests.first);
                        $$.falseList.push_back(bpatchRequests.second);
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }

                        //load operands
                        string operation = ($2.name == "==")? "eq" : "ne";
                        string operand1 = Framework::getInstance().freshTemp();
                        string operand2 = Framework::getInstance().freshTemp();
                        codeManager.emitLoad($1.place, operand1);
                        codeManager.emitLoad($3.place, operand2);

                        //test for (in)equality
                        string boolEquality = Framework::getInstance().freshTemp();
                        codeManager.emitCond(operation, operand1, operand2, boolEquality);

                        //jump accordingly
                        pair<bpatch_address, bpatch_address> bpatchRequests = codeManager.emitIf(boolEquality, "@", "@");
                        $$.trueList.push_back(bpatchRequests.first);
                        $$.falseList.push_back(bpatchRequests.second);
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("INT");
                        }

                        $$.place = $4.place;
                    };
marker_RPAREN:      /*epsilon*/ {Framework::getInstance().addScope(Scope::IF);}
marker_STATEMENT:   /*epsilon*/ {Framework::getInstance().popScope();}

%%

void yyerror(const char*){
	output::errorSyn(yylineno);
	myExit();
}

int main(){
    try{
        // declare externs
        codeManager.emitGlobal( "declare void @exit(i32)" );
        codeManager.emitGlobal( "declare i32 @printf(i8*, ...)" );

        // function printi definition:
        codeManager.emitGlobal("@.int_specifier = internal constant [4 x i8] c\"%d\\0A\\00\"");
        codeManager.emitGlobal(
                string("define void @printi(i32) {call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], ") +
                "[4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0) ret void}"
        );
        //function print definition:
        codeManager.emitGlobal("@.str_specifier = internal constant [4 x i8] c\"%s\\0A\\00\"");
        codeManager.emitGlobal(
                string("define void @print(i8*) {call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], ") +
                "[4 x i8]* @.str_specifier, i32 0, i32 0), i8* %0) ret void}"
        );

        yyparse();
    }
    catch (const Exceptions::AlreadyExistsException& e){
        output::errorDef(yylineno, e.name);
        myExit();
    }
    catch (const Exceptions::IdentifierDoesNotExistException& e){
        output::errorUndef(yylineno, e.name);
        myExit();
    }

    bool mainExists = false;
    for (const Function& func : Framework::getInstance().functions){
        if (func.name == "main" && func.type == "VOID" && func.getParameters().empty()) mainExists = true;
    }
    if (!mainExists){
        output::errorMainMissing();
        myExit();
    }

    codeManager.printGlobalBuffer();
    codeManager.printCodeBuffer();
}